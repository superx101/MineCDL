# 命令解析器
## 介绍

命令解析器是独立于MCDL的模块，使用命令树来解析《我的世界》格式的指令。本项目中使用MCDL解析器来生成命令树，如果你不想使用MCDL，也可以自己编写命令树生成器。

## 命令树

命令树的格式与MCDL中定义的相同，由根节点、枚举、变量、处理函数组成。提供变量类型推断机制，自动补全没有定义类型的变量。

命令树是一种通用的中间结构，因此你也可以编写一个JSON的构建器来通过JSON生成命令树，然后编写一个生成器把命令树转化为java代码。

## 命令树模式

不是所有命令树都能很好地被解析，《我的世界》中常常使用一些固定参数来限定命令树的解析。
例如 `scoreboard objectives` 和 `scoreboard players` 

而MineCDL中的命令树没有强制要求这些限定，而不限定的方式被叫做 `宽松模式`。相反，限定树格式的方式叫做 `严格模式`

### 宽松模式

非限定的方式带来了一定的灵活性。比如下面用MCDL描述的指令树中，仅输入 `test` 时也会对 `f1` 进行匹配。

```
test
    (a)
        f1()
    (b)
        (c)
            f2()
```

### 严格模式

参考宽松模式中的MCDL，为了消除[二义性](#二义性问题)，严格模式禁止了某个结点下存在多个可选结点。

## 二义性问题

在指令解析过程中，一个参数可能对应多个分支，导致程序将不能很好地选择该进入那个分支
，本项目把这种分支不确定称作二义性。

### 可选参数二义性

::: tip
使用 严格模式 构建的树不会出现这个问题
:::

当某一个结点下存在多个可选分支时存在二义性。
以下面的MCDL为例，输入 `test` 时，`f1` `f2` `f3` `f4` 都可能被执行。

```
test
    [v]: Variable
        f1()
    (a)
        f2()
    (b)
        f3()
    (c)
        (d)
            f4()
    <v>: Variable
        f5()

```

#### 解决方案

当前解析器采用 `枚举最小链优先策略` 来解决这个二义性，即匹配深度最小的那个分支，本例中为 `f1` `f2` `f3`。

当分支相同时，优先匹配枚举。若此时还存在多个枚举，则匹配第一个定义的枚举，本例中则为 `f2` 被匹配。

因此，你在定义MCDL时应当注意同个结点下不能存在多个可选结点。
或者选择 `严格模式` TODO 来让程序构建树时检查。

### 变量二义性

::: warning
变量二义性不能被程序检查，往往在定义变量时很容易出现
:::

当某个结点下的多个变量结点间存在交集时，存在该二义性。
以下面MCDL为例，当输入 `test 10` 时，`number` 和 `int` 均可匹配。

```
test
    <number>: Number
        f1()
    <int>: Int
        f2()
```

#### 解决方案

命令解析器根据定义变量的先后顺序，匹配第一个符合条件的分支。
本例中则匹配 `f1`。

如果你想匹配 `f2`，则需要把 int 定义在 number 上方。
**由此可得，在不确定变量间是否存在交集时，应当按照集合范围从上到下依次定义变量。或按一定的优先级定义**。
# MineCDL

[English](./README.md) | 简体中文

MineCDL 是一个 javascript/typescript 库，用于自定义命令解析或为其他平台生成代码。

您可以使用 MCDL（MineCraft Command Definition Language，MineCraft 命令定义语言）快速定义一些命令：

```mcdl
tp | teleport
    <target>: Target << 1
        [target]
            f1()
        <pos>: PosInt << 3
            f2()
    <pos>
        f3()
    random | r
        f4()

alwaysday
    (true|false)
        f1()

help
    f1()
```

这三个命令树相当于下面这些 minecraft 风格的语句：

`tp <target: Target> [target: Target]`

`tp <target: Target> <pos: PosInt>`

`tp <pos: PosInt>`

`tp random`

`tp r`

`teleport <target: Target> [target: Target]`

`teleport <target: Target> <pos: PosInt>`

`teleport <pos: PosInt>`

`teleport random`

`teleport r`

`alwaysday`

`alwaysday true`

`alwaysday false`

`help`

## 安装

运行

```shell
npm install minecdl
```

来安装该库及其所有依赖库。

## MCDL 语法
请参阅[文档](https://superx101.github.io/MineCDL/)

## 命令解析器

对于从 MCDL 生成的命令树，你可以选择使用本库内置的命令解析器进行解析，如下代码所示：

> 有关完整示例，请参阅 [example.ts](https://github.com/superx101/MineCDL/blob/main/example/parser/example.ts) 或 [example.js](https://github.com/superx101/MineCDL/blob/main/example/parser/example.js) 。

```typescript
const parser = new CommandParser(trees[0]); // trees is contructed by CommandTreeBuilder
parser.recordLog = true;

parser
    .registerVarType("Target", (subParams)=>{
        // Check whether the parameters strings can match this type
        const target = new Target(subParams[0]); // Target is your own class you defined
        // If subParams is no match, return null; otherwise, return object
        return validateSync(target).length > 0 ? null : target;
    })
    .registerVarType("PosInt", (subParams)=>{
        const pos = new PosInt(subParams); // PosInt is your own class you defined
        return validateSync(pos).length > 0 ? null : pos;
    })
    .registerFunction("f1", (params, target1, target2)=> {
        // target1 and target2 is variable object you returned at tpParser.registerVarType
        console.log("f1", target1, target2)
    })
    .registerFunction("f2", (params, target, pos)=> {
        console.log("f2", target, pos)
    })
    .registerFunction("f3", (params, pos)=> {
        console.log("f3", pos)
    })
    .registerFunction("f4", (params, distance)=> {
        console.log("f4", params[1], distance)
    })

parser.errorListener = (error, logs, params)=> {
    console.log(error.message)
}
    
console.log(parser.parse("/tp @s @r"));         
// true f1 Target {tag: '@s'} Target {tag: '@r'}
console.log(parser.parse("/cmd1 @s @s"));       
// true f1 Target {tag: '@s'} Target {tag: '@s'}
console.log(parser.parse("/tp @s 10 20 30"));   
// true f2 Target {tag: '@s'} PosInt {x: 10, y: 20, z: 30}
    
parser.head = "#" // default value is "/"
parser.sepRegExp = "_+" // default value is " +"

console.log(parser.parse("#tp_10_20_30"))       
// true f3 PosInt {x: 10, y: 20, z: 30}
console.log(parser.parse("#tp_random"))         
// true f4
console.log(parser.parse("#tp_r"))              
// true f4
console.log(parser.parse("#tp______r"))         
// true f4
console.log(parser.parse("#tp_test"))           
// false Unable to match parameter >>_test<<
```

## 代码生成器

此外，您还可以使用相应的代码生成器生成其他平台和语言的命令注册代码。

> 完整代码请见: [example.ts](https://github.com/superx101/MineCDL/blob/main/example/generator_llbds/example.ts)

以 LiteLoaderBDS 为例，使用 MineCDL 生成一个 javascript 的命令注册类。
只需继承这个类即可完成命令注册。

```js
/**
 * Generated by MineCDL(https://github.com/superx101/MineCDL) v1.1.0
 * 
 * test                                @(description="A example command")
 *     player
 *         <players>: Player << 1
 *             [pos]: BlockPos << 1
 *                 f1()
 *         [pos]: BlockPos << 1
 *             f2()
 *     other | o                       @(name="other", enumOptions=1)
 *         <number>: Int << 1
 *             (replace)
 *                 f3()
 *             hollow
 *                 f4()
 *         [block]: Block << 1
 *             [item]: Item << 1
 *                 f5()
 */

/**
 * An abstract class of register command in LLSE
 * @abstract
 */
class TestCommandAbstract {
    
    constructor() {}
    
    register() {
        const command = mc.newCommand("test", "A example command");
        command.setEnum("player", ["player"]);
        command.setEnum("other", ["other", "o"]);
        command.setEnum("replace", ["replace"]);
        command.setEnum("hollow", ["hollow"]);
        command.optional("replace", ParamType.Enum, "replace", "optional_replace");
        command.optional("pos", ParamType.BlockPos, "", "optional_var_pos");
        command.optional("block", ParamType.Block, "", "optional_var_block");
        command.optional("item", ParamType.Item, "", "optional_var_item");
        command.mandatory("player", ParamType.Enum, "player", "mandatory_player");
        command.mandatory("other", ParamType.Enum, "other", "mandatory_other_o", 1);
        command.mandatory("hollow", ParamType.Enum, "hollow", "mandatory_hollow");
        command.mandatory("players", ParamType.Player, "", "mandatory_var_players");
        command.mandatory("number", ParamType.Int, "", "mandatory_var_number");
        command.overload(["mandatory_player", "mandatory_var_players", "optional_var_pos"]);
        command.overload(["mandatory_player", "optional_var_pos"]);
        command.overload(["mandatory_other_o", "mandatory_var_number", "optional_replace"]);
        command.overload(["mandatory_other_o", "mandatory_var_number", "mandatory_hollow"]);
        command.overload(["mandatory_other_o", "optional_var_block", "optional_var_item"]);
        command.setCallback((command, origin, output, result) => {
            this.callback(command, origin, output, result);
        });
        return command.setup();
    }
    
    callback(command, origin, output, result) {
        if (result.mandatory_player) {
            if (result.mandatory_var_players) {
                return this.f1(result.player, result.players, result.pos);
            }
            else {
                return this.f2(result.player, result.pos);
            }
        }
        else if (result.mandatory_other_o) {
            if (result.mandatory_var_number) {
                if (result.mandatory_hollow) {
                    return this.f4(result.other_o, result.number, result.hollow);
                }
                else {
                    return this.f3(result.other_o, result.number, result.replace);
                }
            }
            else {
                return this.f5(result.other_o, result.block, result.item);
            }
        }
    }
    
    f1(player, players, pos) {}
    
    f2(player, pos) {}
    
    f4(other_o, number, hollow) {}
    
    f3(other_o, number, replace) {}
    
    f5(other_o, block, item) {}
}

module.exports = TestCommandAbstract;
```
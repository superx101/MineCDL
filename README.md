# MineCDL

English | [简体中文](./README-CN.md)

MineCDL is a javascript/typescript library for custom command parsing or generating code for other platforms.

You can quickly define some commands use MCDL (MineCraft Command Definition Language) as :

```mcdl
tp | teleport
    <target>: Target << 1
        [target]
            f1()
        <pos>: PosInt << 3
            f2()
    <pos>
        f3()
    random | r
        f4()

alwaysday
    (true|false)
        f1()

help
    f1()
```

These three command trees are equivalent to these minecraft style statements below :

`tp <target: Target> [target: Target]`

`tp <target: Target> <pos: PosInt>`

`tp <pos: PosInt>`

`tp random`

`tp r`

`teleport <target: Target> [target: Target]`

`teleport <target: Target> <pos: PosInt>`

`teleport <pos: PosInt>`

`teleport random`

`teleport r`

`alwaysday`

`alwaysday true`

`alwaysday false`

`help`

## Installation

Run 

```shell
npm install minecdl
``` 

to install the library and all its dependecies.

## MCDL Syntax
Refer to the [documentation](https://superx101.github.io/MineCDL/)

## Command Parser

For command trees generated from MCDL, you can choose to parse them using the built-in command parser in this library, as demonstrated in the following code:

> For the complete example, please refer to [example.ts](https://github.com/superx101/MineCDL/blob/main/example/parser/example.ts) or [example.js](https://github.com/superx101/MineCDL/blob/main/example/parser/example.js).

```typescript
const parser = new CommandParser(trees[0]); // trees is contructed by CommandTreeBuilder
parser.recordLog = true;

parser
    .registerVarType("Target", (subParams)=>{
        // Check whether the parameters strings can match this type
        const target = new Target(subParams[0]); // Target is your own class you defined
        // If subParams is no match, return null; otherwise, return object
        return validateSync(target).length > 0 ? null : target;
    })
    .registerVarType("PosInt", (subParams)=>{
        const pos = new PosInt(subParams); // PosInt is your own class you defined
        return validateSync(pos).length > 0 ? null : pos;
    })
    .registerFunction("f1", (params, target1, target2)=> {
        // target1 and target2 is variable object you returned at tpParser.registerVarType
        console.log("f1", target1, target2)
    })
    .registerFunction("f2", (params, target, pos)=> {
        console.log("f2", target, pos)
    })
    .registerFunction("f3", (params, pos)=> {
        console.log("f3", pos)
    })
    .registerFunction("f4", (params, distance)=> {
        console.log("f4", params[1], distance)
    })

parser.errorListener = (error, logs, params)=> {
    console.log(error.message)
}
    
console.log(parser.parse("/tp @s @r"));         
// true f1 Target {tag: '@s'} Target {tag: '@r'}
console.log(parser.parse("/cmd1 @s @s"));       
// true f1 Target {tag: '@s'} Target {tag: '@s'}
console.log(parser.parse("/tp @s 10 20 30"));   
// true f2 Target {tag: '@s'} PosInt {x: 10, y: 20, z: 30}
    
parser.head = "#" // default value is "/"
parser.sepRegExp = "_+" // default value is " +"

console.log(parser.parse("#tp_10_20_30"))       
// true f3 PosInt {x: 10, y: 20, z: 30}
console.log(parser.parse("#tp_random"))         
// true f4
console.log(parser.parse("#tp_r"))              
// true f4
console.log(parser.parse("#tp______r"))         
// true f4
console.log(parser.parse("#tp_test"))           
// false Unable to match parameter >>_test<<
```

## Code Generators

In addition, you can generate command registration code for other platforms and languages using the appropriate code generators.

> For the full code see: [example.ts](https://github.com/superx101/MineCDL/blob/main/example/generator_llbds/example.ts)

As an example, LiteLoaderBDS uses MineCDL to generate a javascript command registration class.
Just inherit from this class to accomplish command registration.

```js
/**
 * Generated by MineCDL(https://github.com/superx101/MineCDL) v1.1.1
 * 
 * test                                @(description="A example command")
 *     player
 *         <players>: Player << 1
 *             [pos]: BlockPos << 1
 *                 f1()
 *         [pos]: BlockPos << 1
 *             f2()
 *     other | o                       @(name="other", enumOptions=1)
 *         <number>: Int << 1
 *             (replace)
 *                 f3()
 *             hollow
 *                 f4()
 *         [block]: Block << 1
 *             [item]: Item << 1
 *                 f5()
 */

/**
 * An abstract class of register command in LLSE
 * @abstract
 */
class TestCommandAbstract {
    
    constructor() {}
    
    register() {
        const command = mc.newCommand("test", "A example command");
        command.setEnum("player", ["player"]);
        command.setEnum("other", ["other", "o"]);
        command.setEnum("replace", ["replace"]);
        command.setEnum("hollow", ["hollow"]);
        command.optional("replace", ParamType.Enum, "replace", "optional_replace");
        command.optional("pos", ParamType.BlockPos, "", "optional_var_pos");
        command.optional("block", ParamType.Block, "", "optional_var_block");
        command.optional("item", ParamType.Item, "", "optional_var_item");
        command.mandatory("player", ParamType.Enum, "player", "mandatory_player");
        command.mandatory("other", ParamType.Enum, "other", "mandatory_other_o", 1);
        command.mandatory("hollow", ParamType.Enum, "hollow", "mandatory_hollow");
        command.mandatory("players", ParamType.Player, "", "mandatory_var_players");
        command.mandatory("number", ParamType.Int, "", "mandatory_var_number");
        command.overload(["mandatory_player", "mandatory_var_players", "optional_var_pos"]);
        command.overload(["mandatory_player", "optional_var_pos"]);
        command.overload(["mandatory_other", "mandatory_var_number", "optional_replace"]);
        command.overload(["mandatory_other", "mandatory_var_number", "mandatory_hollow"]);
        command.overload(["mandatory_other", "optional_var_block", "optional_var_item"]);
        command.setCallback((command, origin, output, result) => {
            this.callback(command, origin, output, result);
        });
        return command.setup();
    }
    
    callback(command, origin, output, result) {
        if (result.player !== undefined) {
            if (result.players !== undefined) {
                return this.f1(result.player, result.players, result.pos);
            }
            return this.f2(result.player, result.pos);
        }
        else if (result.other !== undefined) {
            if (result.number !== undefined) {
                if (result.hollow !== undefined) {
                    return this.f4(result.other, result.number, result.hollow);
                }
                return this.f3(result.other, result.number, result.replace);
            }
            return this.f5(result.other, result.block, result.item);
        }
    }
    
    f1(player, players, pos) {}
    
    f2(player, pos) {}
    
    f4(other, number, hollow) {}
    
    f3(other, number, replace) {}
    
    f5(other, block, item) {}
}

module.exports = TestCommandAbstract;
```
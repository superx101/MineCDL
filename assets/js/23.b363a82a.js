(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{305:function(e,t,a){"use strict";a.r(t);var o=a(14),n=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"command-parser"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#command-parser"}},[e._v("#")]),e._v(" Command parser")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("Translated with www.DeepL.com/Translator")])]),e._v(" "),t("h2",{attrs:{id:"introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),t("p",[e._v("The command parser is a separate module from MCDL that uses a command tree to parse commands in My World format. This project uses the MCDL parser to generate the command tree. If you don't want to use MCDL, you can also write your own command tree generator.")]),e._v(" "),t("h2",{attrs:{id:"command-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#command-tree"}},[e._v("#")]),e._v(" Command tree")]),e._v(" "),t("p",[e._v("The format of the command tree is the same as that defined in MCDL, consisting of a root node, enumerations, variables, and handler functions. A variable type inference mechanism is provided to automatically complete variables of undefined types.")]),e._v(" "),t("p",[e._v("Command tree is a generic intermediate structure, so you can also write a JSON builder to generate the command tree from JSON, and then write a generator to convert the command tree to java code.")]),e._v(" "),t("h2",{attrs:{id:"command-tree-modes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#command-tree-modes"}},[e._v("#")]),e._v(" Command tree modes")]),e._v(" "),t("p",[e._v("Not all command trees are parsed well, and My World often uses some fixed parameters to qualify the parsing of command trees.\nFor example, "),t("code",[e._v("scoreboard objectives")]),e._v(" and "),t("code",[e._v("scoreboard players")]),e._v(".")]),e._v(" "),t("p",[e._v("The command tree in MineCDL does not enforce these qualifications, and the way in which it is not qualified is called "),t("code",[e._v("loose mode''. Instead, the way the tree is formatted is called")]),e._v("strict mode''.")]),e._v(" "),t("h3",{attrs:{id:"loose-mode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loose-mode"}},[e._v("#")]),e._v(" Loose mode")]),e._v(" "),t("p",[e._v("The unqualified approach provides some flexibility. For example, in the following command tree described in MCDL, "),t("code",[e._v("f1")]),e._v(" is also matched when only "),t("code",[e._v("test")]),e._v(" is entered.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("test\n    (a)\n        f1()\n    (b)\n        (c)\n            f2()\n")])])]),t("h3",{attrs:{id:"strict-mode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#strict-mode"}},[e._v("#")]),e._v(" Strict mode")]),e._v(" "),t("p",[e._v("Referring to MCDL in loose mode, to eliminate [duality] (## duality problem), strict mode prohibits the existence of multiple optional nodes under a given node.")]),e._v(" "),t("h2",{attrs:{id:"ambiguity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ambiguity"}},[e._v("#")]),e._v(" Ambiguity")]),e._v(" "),t("p",[e._v("During instruction parsing, a single argument may correspond to more than one branch, resulting in a program that will not be able to make a good choice of which branch to go into\nThis project refers to this branching uncertainty as duality.")]),e._v(" "),t("h3",{attrs:{id:"optional-parameter-duality"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optional-parameter-duality"}},[e._v("#")]),e._v(" Optional parameter duality")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("Trees built using strict mode do not suffer from this problem.")])]),e._v(" "),t("p",[e._v("Duality exists when there are multiple optional branches under a node.\nTake the following MCDL as an example, when typing "),t("code",[e._v("test")]),e._v(", "),t("code",[e._v("f1")]),e._v(" "),t("code",[e._v("f2")]),e._v(" "),t("code",[e._v("f3")]),e._v(" "),t("code",[e._v("f4")]),e._v(" may all be executed.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("test\n    [v]: Variable\n        f1()\n    (a)\n        f2()\n    (b)\n        f3()\n    (c)\n        (d)\n            f4()\n    <v>: Variable\n        f5()\n\n")])])]),t("h4",{attrs:{id:"solution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solution"}},[e._v("#")]),e._v(" Solution")]),e._v(" "),t("p",[e._v("The current parser resolves this dichotomy using the "),t("code",[e._v("enumeration least chain first strategy")]),e._v(", i.e., it matches the branch with the least depth, in this case "),t("code",[e._v("f1")]),e._v(" "),t("code",[e._v("f2")]),e._v(" "),t("code",[e._v("f3")]),e._v(".")]),e._v(" "),t("p",[e._v("When the branches are the same, the enumeration is matched first. If more than one enumeration exists at this point, the first defined enumeration is matched, in this case "),t("code",[e._v("f2")]),e._v(" is matched.")]),e._v(" "),t("p",[e._v("Therefore, you should be careful not to have more than one optional node under the same node when defining the MCDL.\nAlternatively, choose "),t("code",[e._v("strict mode")]),e._v(" TODO to have the program check this when building the tree.")]),e._v(" "),t("h3",{attrs:{id:"variable-duality"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#variable-duality"}},[e._v("#")]),e._v(" Variable duality")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),t("p",[e._v("Variable duality cannot be checked by the program, and is often easily seen when defining variables.")])]),e._v(" "),t("p",[e._v("This duality exists when there is an intersection between multiple variable nodes under a given node.\nFor example, in the following MCDL, when "),t("code",[e._v("test 10")]),e._v(" is entered, both "),t("code",[e._v("number")]),e._v(" and "),t("code",[e._v("int")]),e._v(" match.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("test\n    <number>: Number\n        f1()\n    <int>: Int\n        f2()\n")])])]),t("h4",{attrs:{id:"solution-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solution-2"}},[e._v("#")]),e._v(" Solution")]),e._v(" "),t("p",[e._v("The command parser matches the first branch that matches the condition based on the order in which the variables are defined.\nIn this case, it matches "),t("code",[e._v("f1")]),e._v(".")]),e._v(" "),t("p",[e._v("If you want to match "),t("code",[e._v("f2")]),e._v(", you need to define int above number.\n** It follows from this that when you are not sure if there is an intersection between variables, you should define variables in order from top to bottom of the set range. Or define them in a certain order of priority**.")])])}),[],!1,null,null,null);t.default=n.exports}}]);